from __future__ import annotations

import logging
import math
import random
import socket
import string
from dataclasses import dataclass

try:
    from rich.logging import RichHandler

    logging.basicConfig(level=logging.INFO, handlers=[RichHandler()])
except ImportError:
    logging.basicConfig(level=logging.INFO)
socket.setdefaulttimeout(3)

# Mostly "borrowed" from checkers :)


def randstr(
    length: int, extra: str = "", chars: str = string.ascii_letters + string.digits
) -> str:
    return "".join(random.choices(chars + extra, k=length))


def randstrl(
    min: int,
    max: int,
    extra: str = "",
    chars: str = string.ascii_letters + string.digits,
) -> str:
    return randstr(random.randint(min, max), extra, chars)


def popcount(x: int) -> int:
    return bin(x).count("1")


@dataclass
class Point:
    x: int
    y: int

    def __add__(self, other: Point) -> Point:
        return Point(self.x + other.x, self.y + other.y)

    def __sub__(self, other: Point) -> Point:
        return Point(self.x - other.x, self.y - other.y)

    def sqr_mag(self) -> int:
        return self.x**2 + self.y**2

    def mag(self) -> float:
        return math.sqrt(self.sqr_mag())


def encode_signal_data(data: bytes, modulation: bytes, pad: bytes = b" ") -> bytearray:
    if len(data) % 8 != 0:
        data += (pad * 8)[: 8 - (len(data) % 8)]
    output = bytearray()
    offset = 0
    while len(data) != offset:
        mod = modulation[offset % len(modulation)]
        block = data[offset : offset + 8]
        output.append(block[0] ^ (mod & (1 << 7)))
        output.append(block[1] ^ (mod & (1 << 6)))
        output.append(block[2] ^ (mod & (1 << 5)))
        output.append(block[3] ^ (mod & (1 << 4)))
        output.append(
            ((popcount(block[0]) & 1) << 7)
            | ((popcount(block[1]) & 1) << 6)
            | ((popcount(block[2]) & 1) << 5)
            | ((popcount(block[3]) & 1) << 4)
            | ((popcount(block[4]) & 1) << 3)
            | ((popcount(block[5]) & 1) << 2)
            | ((popcount(block[6]) & 1) << 1)
            | ((popcount(block[7]) & 1) << 0)
        )
        output.append(block[4] ^ (mod & (1 << 3)))
        output.append(block[5] ^ (mod & (1 << 2)))
        output.append(block[6] ^ (mod & (1 << 1)))
        output.append(block[7] ^ (mod & (1 << 0)))
        offset += 8
    return output


def decode_signal_data(data: bytearray) -> tuple[bytes, bytes]:
    # -> [data, modulation]
    assert len(data) % 9 == 0
    output = bytearray()
    modulation = bytearray()
    offset = 0
    while len(data) != offset:
        block = data[offset : offset + 9]
        output.append(block[0] ^ ((((block[4] >> 7) ^ popcount(block[0])) & 1) << 7))
        output.append(block[1] ^ ((((block[4] >> 6) ^ popcount(block[1])) & 1) << 6))
        output.append(block[2] ^ ((((block[4] >> 5) ^ popcount(block[2])) & 1) << 5))
        output.append(block[3] ^ ((((block[4] >> 4) ^ popcount(block[3])) & 1) << 4))
        output.append(block[5] ^ ((((block[4] >> 3) ^ popcount(block[5])) & 1) << 3))
        output.append(block[6] ^ ((((block[4] >> 2) ^ popcount(block[6])) & 1) << 2))
        output.append(block[7] ^ ((((block[4] >> 1) ^ popcount(block[7])) & 1) << 1))
        output.append(block[8] ^ ((((block[4] >> 0) ^ popcount(block[8])) & 1) << 0))
        modulation.append(
            ((((block[4] >> 7) ^ popcount(block[0])) & 1) << 7)
            | ((((block[4] >> 6) ^ popcount(block[1])) & 1) << 6)
            | ((((block[4] >> 5) ^ popcount(block[2])) & 1) << 5)
            | ((((block[4] >> 4) ^ popcount(block[3])) & 1) << 4)
            | ((((block[4] >> 3) ^ popcount(block[5])) & 1) << 3)
            | ((((block[4] >> 2) ^ popcount(block[6])) & 1) << 2)
            | ((((block[4] >> 1) ^ popcount(block[7])) & 1) << 1)
            | ((((block[4] >> 0) ^ popcount(block[8])) & 1) << 0)
        )
        offset += 9
    return (output, modulation)


class Conn:
    def __init__(self, ip: str, port: int, recv_size: int = 1024):
        self.ip = ip
        self.port = port
        self.buffer = bytearray()
        self.RECV_SIZE = recv_size
        self.open()

    def open(self):
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.connect((self.ip, self.port))

    def close(self):
        self.s.close()

    def _recv(self, timeout: float | None = None) -> bytes:
        if timeout is None:
            x = self.s.recv(self.RECV_SIZE)
        else:
            original = self.s.timeout
            self.s.settimeout(timeout)
            x = self.s.recv(self.RECV_SIZE)
            self.s.settimeout(original)
        logging.debug("Received %s bytes: %s", len(x), repr(x))
        return x

    def _recv_eof_check(self, timeout: float | None = None) -> bytes:
        x = self._recv(timeout)
        if len(x) == 0:
            raise EOFError(f"Unexpected connection EOF")
        return x

    def peek(self, timeout: float | None = None) -> bytes:
        if len(self.buffer) == 0:
            self.buffer += self._recv_eof_check(timeout)
        return bytes(self.buffer)

    def recv(self, timeout: float | None = None) -> bytes:
        """Receives *some* data. No gurantee about size of received data."""
        if len(self.buffer) == 0:
            return self._recv_eof_check(timeout)
        output = self.buffer
        self.buffer = bytearray()
        return bytes(output)

    def recv_until(
        self, target: bytes | str, drop: bool = True, timeout: float | None = None
    ) -> bytes:
        if isinstance(target, str):
            target = target.encode()
        logging.debug(
            "recv_until(%s); Current buffer: %s", repr(target), repr(self.buffer)
        )
        while True:
            index = self.buffer.find(target)
            if index != -1:
                output = self.buffer[0 : index + (0 if drop else len(target))]
                self.buffer = self.buffer[index + len(target) :]
                return bytes(output)
            self.buffer += self._recv_eof_check(timeout)

    def recv_line(self, drop: bool = True, timeout: float | None = None) -> bytes:
        return self.recv_until(b"\n", drop, timeout)

    def send(self, data: bytes | str):
        if isinstance(data, str):
            data = data.encode()
        logging.debug("Sending %s bytes: %s", len(data), repr(data))
        self.s.send(data)

    def send_line(self, data: bytes | str):
        if isinstance(data, str):
            self.send(data + "\n")
        else:
            self.send(data + b"\n")


def make_conn(
    ip: str = "127.0.0.1",
    port: int = 9999,
    user: str | None = None,
    password: str | None = None,
) -> tuple[Conn, str, str]:
    c = Conn(ip, port)
    user = user or randstr(20)
    password = password or randstr(20)
    c.recv_line()
    c.send_line(user)
    c.recv_line()
    c.send_line(password)
    c.recv_until("accepting commands:\n")
    logging.info("Logged as %s:%s", user, password)
    return (c, user, password)
